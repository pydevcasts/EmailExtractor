Ø§ÛŒÙ† Ú©Ø¯ ÛŒÚ© Ø¨Ø±Ù†Ø§Ù…Ù‡ Ø¨Ø±Ø§ÛŒ Ø§ØªØµØ§Ù„ Ø¨Ù‡ ØªÙ„Ú¯Ø±Ø§Ù… Ø¨Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡ÛŒ Telethon Ø§ÛŒØ¬Ø§Ø¯ Ù…ÛŒÚ©Ù†Ø¯ Ùˆ Ø§Ù…Ú©Ø§Ù† Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù…Ù‡Ø§ Ø¨Ù‡ ØªØ¹Ø¯Ø§Ø¯ÛŒ Ù…Ø´Ø®Øµ Ø§Ø² Ú¯ÙØªÚ¯ÙˆÙ‡Ø§ ÛŒØ§ Ú¯Ø±ÙˆÙ‡Ù‡Ø§ Ø¯Ø± Ø²Ù…Ø§Ù†Ù‡Ø§ÛŒ Ù…Ø¹ÛŒÙ† Ø±Ø§ ÙØ±Ø§Ù‡Ù… Ù…ÛŒØ¢ÙˆØ±Ø¯. 

Ø¯Ø± Ø§ÛŒÙ†Ø¬Ø§ ØªÙˆØ¶ÛŒØ­Ø§Øª Ø¨Ø®Ø´Ù‡Ø§ÛŒ Ù…Ù‡Ù… Ú©Ø¯ Ø¢ÙˆØ±Ø¯Ù‡ Ø´Ø¯Ù‡Ø§Ù†Ø¯:

1. **ÙˆØ§Ø±Ø¯ Ú©Ø±Ø¯Ù† Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡Ù‡Ø§ Ùˆ Ù…Ø§Ú˜ÙˆÙ„Ù‡Ø§**: Ø¯Ø± Ø§ÛŒÙ† Ø¨Ø®Ø´ØŒ Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡Ù‡Ø§ Ùˆ Ù…Ø§Ú˜ÙˆÙ„Ù‡Ø§ÛŒ Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² ÙˆØ§Ø±Ø¯ Ù…ÛŒØ´ÙˆÙ†Ø¯. Ø§Ú¯Ø± Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡Ø§ÛŒ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯ØŒ Ú©Ø¯ ØªÙ„Ø§Ø´ Ù…ÛŒÚ©Ù†Ø¯ Ø¢Ù† Ø±Ø§ Ù†ØµØ¨ Ú©Ù†Ø¯.

2. **ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ùˆ Ù†Ú¯Ø§Ù‡Ø¯Ø§Ø´Øª Ù„Ø§Ú¯**: ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø¨Ø±Ø§ÛŒ Ø«Ø¨Øª Ù„Ø§Ú¯Ù‡Ø§ Ø¯Ø± ÛŒÚ© ÙØ§ÛŒÙ„ ØªØ¹ÛŒÛŒÙ† Ø´Ø¯Ù‡ Ø§Ø³Øª.

3. **ØªØ¹Ø±ÛŒÙ ØªÙˆØ§Ø¨Ø¹ Ú©Ù…Ú©ÛŒ**: ØªÙˆØ§Ø¨Ø¹ÛŒ Ø¨Ø±Ø§ÛŒ Ø®ÙˆØ§Ù†Ø¯Ù† Ùˆ Ù†ÙˆØ´ØªÙ† Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø§Ø² ÛŒÚ© ÙØ§ÛŒÙ„ JSON Ùˆ ÛŒÚ© ØªØ§Ø¨Ø¹ Ø¨Ø±Ø§ÛŒ ØªØºÛŒÛŒØ± ÙÙˆÙ†Øª Ù…ØªÙ†Ù‡Ø§ ØªØ¹Ø±ÛŒÙ Ø´Ø¯Ù‡Ø§Ù†Ø¯.

4. **Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¬ÙˆØ¯ ÙØ§ÛŒÙ„ Ø¯Ø§Ø¯Ù‡Ù‡Ø§**: Ø§Ú¯Ø± ÙØ§ÛŒÙ„ Ø¯Ø§Ø¯Ù‡Ù‡Ø§ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯ØŒ ÛŒÚ© ÙØ§ÛŒÙ„ Ø¯Ø§Ø¯Ù‡Ù‡Ø§ÛŒ Ù¾ÛŒØ´ÙØ±Ø¶ Ø³Ø§Ø®ØªÙ‡ Ùˆ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø§ÙˆÙ„ÛŒÙ‡ Ø¯Ø± Ø¢Ù† Ø°Ø®ÛŒØ±Ù‡ Ù…ÛŒØ´ÙˆÙ†Ø¯.

5. **ØªØ¹Ø±ÛŒÙ Ù…ØªØºÛŒØ±Ù‡Ø§**: Ø´Ù†Ø§Ø³Ù‡ Ùˆ Ú©Ù„ÛŒØ¯ API Ø¨Ø±Ø§ÛŒ Ø§ØªØµØ§Ù„ Ø¨Ù‡ ØªÙ„Ú¯Ø±Ø§Ù…ØŒ Ù†Ø§Ù… Ø³Ø´Ù† (Ø¬Ù„Ø³Ù‡) Ùˆ Ø´Ù†Ø§Ø³Ù‡ ØªÙˆØ³Ø¹Ù‡Ø¯Ù‡Ù†Ø¯Ù‡ ØªØ¹Ø±ÛŒÙ Ø´Ø¯Ù‡Ø§Ù†Ø¯.

6. **ØªØ¹Ø±ÛŒÙ ØªØ§Ø¨Ø¹ Ø§Ù†ØªÙ‚Ø§Ù„ Ù¾ÛŒØ§Ù…**: Ø§ÛŒÙ† ØªØ§Ø¨Ø¹ Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… Ø¨Ù‡ Ú¯ÙØªÚ¯ÙˆÙ‡Ø§ ÛŒØ§ Ú¯Ø±ÙˆÙ‡Ù‡Ø§ ØªØ¹Ø±ÛŒÙ Ø´Ø¯Ù‡ Ùˆ Ø§Ø² ØªØ§Ø¨Ø¹ Telethon Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒÚ©Ù†Ø¯.

7. **ØªÙ†Ø¸ÛŒÙ… Ø§Ø±Ø³Ø§Ù„ Ø®ÙˆØ¯Ú©Ø§Ø±**: Ø§ÛŒÙ† Ù‚Ø³Ù…Øª Ø¨Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡ aiocron Ø²Ù…Ø§Ù†Ù‡Ø§ÛŒÛŒ Ø±Ø§ ØªØ¹ÛŒÛŒÙ† Ù…ÛŒÚ©Ù†Ø¯ Ú©Ù‡ Ø¨Ø§ÛŒØ¯ Ù¾ÛŒØ§Ù…Ù‡Ø§ Ø±Ø§ Ø¨Ù‡ Ù…Ù‚Ø§ØµØ¯ Ù…Ø´Ø®Øµ ÙØ±Ø³ØªØ§Ø¯Ù‡ Ùˆ ØªØ§Ø¨Ø¹ Ù…Ø±Ø¨ÙˆØ·Ù‡ Ø±Ø§ ÙØ±Ø§Ø®ÙˆØ§Ù†ÛŒ Ú©Ù†Ø¯.

8. **ØªÙ†Ø¸ÛŒÙ… Ø§Ø´ØªØ±Ø§Ú©**: Ø§ÛŒÙ† Ù‚Ø³Ù…Øª Ù†ÛŒØ² Ø¨Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡ aiocron Ø²Ù…Ø§Ù†Ù‡Ø§ÛŒÛŒ Ø±Ø§ ØªØ¹ÛŒÛŒÙ† Ù…ÛŒÚ©Ù†Ø¯ Ú©Ù‡ Ø¨Ø§ÛŒØ¯ Ø§Ø´ØªØ±Ø§Ú© Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ø±Ø§ Ø¨Ø±Ø±Ø³ÛŒ Ùˆ Ø§Ø¹Ù„Ø§Ù… Ú©Ù†Ø¯.

9. **Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø¯Ø±ÛŒØ§ÙØª Ù¾ÛŒØ§Ù…**: Ø¯Ø± Ø§ÛŒÙ†Ø¬Ø§ ÛŒÚ© ÙˆØ§Ú©Ø´ÛŒÚ©Ù†Ù†Ø¯Ù‡ (event handler) Ø¨Ø±Ø§ÛŒ Ø¯Ø±ÛŒØ§ÙØª Ù¾ÛŒØ§Ù…Ù‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯ ØªØ¹Ø±ÛŒÙ Ø´Ø¯Ù‡ Ø§Ø³Øª.

Ù…ØªÙ† Ú©Ø¯ Ø±Ø§ Ø¨Ù‡ Ø²Ø¨Ø§Ù† ÙØ§Ø±Ø³ÛŒ Ù…ÛŒÙ†ÙˆÛŒØ³Ù… Ùˆ ØªÙˆØ¶ÛŒØ­Ø§Øª Ù‡Ø± Ø¨Ø®Ø´ Ø±Ø§ Ø¨Ø±Ø±Ø³ÛŒ Ù…ÛŒÚ©Ù†Ù….

Ù…Ø·Ù…Ø¦Ù†Ø§Ù‹! Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ú©Ø¯ Ø±Ø§ Ø¨Ø§ ØªÙˆØ¶ÛŒØ­Ø§Øª ÙØ§Ø±Ø³ÛŒ ØªÙˆØ¶ÛŒØ­ Ù…ÛŒØ¯Ù‡Ù…:

python
import os
import re
import json
import random
import aiocron
import asyncio
import logging
from telethon.sync import TelegramClient, events, functions, types
from telethon.errors.rpcerrorlist import FloodWaitError

# Ø§Ú¯Ø± Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡Ù‡Ø§ Ù†ØµØ¨ Ù†Ø¨Ø§Ø´Ù†Ø¯ØŒ Ø¢Ù†Ù‡Ø§ Ø±Ø§ Ù†ØµØ¨ Ù…ÛŒÚ©Ù†ÛŒÙ…
try:
    import os
    import re
    import json
    import random
    import aiocron
    import asyncio
    import logging
    from telethon.sync import TelegramClient, events, functions, types
    from telethon.errors.rpcerrorlist import FloodWaitError
except ModuleNotFoundError:
    os.system('pip install --upgrade pip && pip install telethon && pip install asyncio && pip install aiocron && clear')
    os.sys.exit('Ø¨Ø³ØªÙ‡Ù‡Ø§ÛŒ Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ù†ØµØ¨ Ø´Ø¯Ù†Ø¯!')

# ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù„Ø§Ú¯Ù‡Ø§
logging.basicConfig(filename="log.txt", filemode="a+", format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)

# ØªÙˆØ§Ø¨Ø¹ Ú©Ù…Ú©ÛŒ
def get(file):
    with open(file, 'r') as r:
        return json.load(r)

def put(file, data):
    with open(file, 'w') as w:
        json.dump(data, w, indent=4)

def font(text):
    if isinstance(text, str):
        text = text.lower()
        return text.translate(text.maketrans('qwertyuiopasdfghjklzxcvbnm-0123456789',
                                             'Ç«á´¡á´‡Ê€á´›Êá´œÉªá´á´˜á´€sá´…Ò“É¢Êœá´Šá´‹ÊŸá´¢xá´„á´ Ê™É´á´-ðŸŽðŸðŸðŸ‘ðŸ’ðŸ“ðŸ”ðŸ•ðŸ–ðŸ—'))
    else:
        return None

# Ø§Ú¯Ø± ÙØ§ÛŒÙ„ Ø¯Ø§Ø¯Ù‡Ù‡Ø§ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯ØŒ ÛŒÚ© ÙØ§ÛŒÙ„ Ø¯Ø§Ø¯Ù‡Ù‡Ø§ÛŒ Ù¾ÛŒØ´ÙØ±Ø¶ Ø§ÛŒØ¬Ø§Ø¯ Ù…ÛŒÚ©Ù†ÛŒÙ…
if not os.path.exists('data.json'):
    data = {'bot': 'on', 'autojoin': 'off', 'contact': 'off', 'secretary': 'off', 'forward': 'on',
            'forwardauthor': 'off', 'forwardtime': 10, 'forwardid': 0, 'forwardchat': None, 'forwardtype': None,
            'forwardreply': None, 'subscription': 30, 'admins': [], 'groups': [], 'secretarytext': []}
    put('data.json', data)

api_id = 00000000  # Ø´Ù†Ø§Ø³Ù‡ API
api_hash = '000000'  # Ú©Ù„ÛŒØ¯ API

bot = TelegramClient(input('Ù†Ø§Ù… Ø¬Ù„Ø³Ù‡ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯: '), api_id, api_hash)  # Ø§ØªØµØ§Ù„ Ø¨Ù‡ ØªÙ„Ú¯Ø±Ø§Ù…
dev = 000000  # Ø´Ù†Ø§Ø³Ù‡ ØªÙˆØ³Ø¹Ù‡Ø¯Ù‡Ù†Ø¯Ù‡

# ØªØ§Ø¨Ø¹ Ø¨Ø±Ø§ÛŒ Ø§Ù†ØªÙ‚Ø§Ù„ Ù¾ÛŒØ§Ù…
async def forward_message(to_peer, id, from_peer, reply_text, drop_author):
    message = await bot(
        functions.messages.ForwardMessagesRequest(
            from_peer=from_peer,
            id=[id],
            to_peer=to_peer,
            drop_author=drop_author
        )
    )
    if reply_text:
        await bot.send_message(to_peer, reply_text, reply_to=message.updates[0].id)

forwardtime = get('data.json')['forwardtime']  # Ø²Ù…Ø§Ù† Ø§Ø±Ø³Ø§Ù„ Ø®ÙˆØ¯Ú©Ø§Ø±

# ØªÙ†Ø¸ÛŒÙ… Ø²Ù…Ø§Ù†Ø¨Ù†Ø¯ÛŒ Ø§Ø±Ø³Ø§Ù„ Ø®ÙˆØ¯Ú©Ø§Ø±
@aiocron.crontab(f'*/{forwardtime}    ')
async def clock():
    data = get('data.json')
    if data['bot'] == 'on' and data['subscription'] != 0:
        if data['forward'] == 'on':
            if data['forwardid'] and data['forwardchat'] and data['forwardtype']:
                i, limit_for_send = 0, 0
                async for dialog in bot.iter_dialogs():
                    if (data['forwardtype'] == 'privates' and isinstance(dialog.entity, types.User)) or \
                            (data['forwardtype'] == 'groups' and isinstance(dialog.entity, types.Chat)) or \
                            (data['forwardtype'] == 'super groups' and isinstance(dialog.entity, types.Channel) and
                             dialog.entity.megagroup):
                        try:
                            await forward_message(dialog.id, data['forwardid'], data['forwardchat'],
                                                  data['forwardreply'], data['forwardauthor'] == 'off')
                            i += 1
                            await asyncio.sleep(0.5)
                        except FloodWaitError as error:
                            limit_for_send = e.seconds
                            try:
                                await bot.send_message(dev, error)
                            except:
                                ...
                            print(error)
                            break
                        except Exception as e:
                            await bot.send_message(dev, font(e))
                print(f"Ù…Ø­Ø¯ÙˆØ¯ÛŒØª FloodWaitError Ø¨Ø§Øª: {limit_for_send} Ø«Ø§Ù†ÛŒÙ‡")
                if limit_for_send:
                    await asyncio.sleep(limit_for_send)
                    await bot.send_message(dev, font(f"Ù…Ø­Ø¯ÙˆØ¯ÛŒØª FloodWaitError Ø¨Ø§Øª: {limit_for_send} Ø«Ø§Ù†ÛŒÙ‡"))
                await asyncio.sleep(1)
                await bot.send_message(dev, font(f'Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯Ù‡ Ø¨Ù‡ {i} Ø§Ø² ' + data['forwardtype'] + ' !'))

# ØªÙ†Ø¸ÛŒÙ… Ø§Ø´ØªØ±Ø§Ú© Ùˆ Ø²Ù…Ø§Ù†Ø¨Ù†Ø¯ÛŒ Ø¢Ù†
@aiocron.crontab(f'*/12 12   *')
async def subscription():
    data = get('data.json')
    if data['subscription'] > 0:
        data['subscription'] -= 1
        put('data.json', data)
    else:
        await bot.send_message(dev, font('Ø§Ø´ØªØ±Ø§Ú© Ø§ÛŒÙ† ØªØ¨Ú†ÛŒ Ø¨Ù‡ Ø§ØªÙ…Ø§Ù… Ø±Ø³ÛŒØ¯Ù‡ Ø§Ø³Øª!'))

# ÙˆØ§Ú©Ø´ÛŒ Ù¾ÛŒØ§Ù…Ù‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯
@bot.on(events.NewMessage())
async def updateMessage(event):
    pass  # Ø§ÛŒÙ† Ù‚Ø³Ù…Øª Ø®Ø§Ù„ÛŒ Ø§Ø³Øª Ùˆ Ø¨Ø±Ø§ÛŒ Ù¾ÛŒØ§Ø¯Ù‡Ø³Ø§Ø²ÛŒ Ù¾Ø±Ø¯Ø§Ø²Ø´ Ù¾ÛŒØ§Ù…Ù‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯ Ø¨Ø§ÛŒØ¯ Ù¾Ø± Ø´ÙˆØ¯

# Ø´Ø±ÙˆØ¹ Ø§ØªØµØ§Ù„ Ø¨Ù‡ ØªÙ„Ú¯Ø±Ø§Ù…
bot.start()
bot.run

_until_disconnected()


Ø¯Ø± Ø§ÛŒÙ†Ø¬Ø§ Ú©Ø¯ÛŒ Ø§Ø³Øª Ú©Ù‡ Ø§ØªØµØ§Ù„ Ø¨Ù‡ ØªÙ„Ú¯Ø±Ø§Ù… Ø±Ø§ Ø¨Ø±Ù‚Ø±Ø§Ø± Ú©Ø±Ø¯Ù‡ Ùˆ Ø§Ù…Ú©Ø§Ù† Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù…Ù‡Ø§ÛŒ Ø®ÙˆØ¯Ú©Ø§Ø± Ø¨Ù‡ Ú¯ÙØªÚ¯ÙˆÙ‡Ø§ ÛŒØ§ Ú¯Ø±ÙˆÙ‡Ù‡Ø§ Ø±Ø§ ÙØ±Ø§Ù‡Ù… Ù…ÛŒØ¢ÙˆØ±Ø¯. Ø§ÛŒÙ† Ø¨Ø±Ù†Ø§Ù…Ù‡ Ø§Ø² Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡ Telethon Ø¨Ø±Ø§ÛŒ Ø§Ø±ØªØ¨Ø§Ø· Ø¨Ø§ ØªÙ„Ú¯Ø±Ø§Ù… Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒÚ©Ù†Ø¯ Ùˆ Ø¨Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² aiocron Ù…Ø¯ÛŒØ±ÛŒØª Ùˆ Ø²Ù…Ø§Ù†Ø¨Ù†Ø¯ÛŒ Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù…Ù‡Ø§ Ø±Ø§ Ø§Ù†Ø¬Ø§Ù… Ù…ÛŒØ¯Ù‡Ø¯. Ù‡Ù…Ú†Ù†ÛŒÙ† Ø§Ø² ÛŒÚ© ÙØ§ÛŒÙ„ JSON Ø¨Ø±Ø§ÛŒ Ø°Ø®ÛŒØ±Ù‡ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ùˆ ÙˆØ¶Ø¹ÛŒØªÙ‡Ø§ÛŒ Ù…Ø®ØªÙ„Ù Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒÚ©Ù†Ø¯.
Ø¯Ø± Ø§ÛŒÙ† Ø¨Ø®Ø´ Ø§Ø² Ú©Ø¯ØŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù…Ø±ØªØ¨Ø· Ø¨Ø§ Ú¯ÙØªÚ¯ÙˆÙ‡Ø§ Ùˆ Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ø±Ø§ Ø¬Ù…Ø¹Ø¢ÙˆØ±ÛŒ Ùˆ Ù†Ù…Ø§ÛŒØ´ Ù…ÛŒØ¯Ù‡Ø¯ Ùˆ Ù‡Ù…Ú†Ù†ÛŒÙ† Ø§Ù…Ú©Ø§Ù† Ø§ÙØ²ÙˆØ¯Ù† Ùˆ Ø­Ø°Ù Ø§ÙØ±Ø§Ø¯ Ù…Ø¯ÛŒØ± (Ø³ÙˆØ¯Ùˆ) Ùˆ ØªØºÛŒÛŒØ± Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ø±Ø§ ÙØ±Ø§Ù‡Ù… Ù…ÛŒØ¢ÙˆØ±Ø¯. Ø§ÛŒÙ† Ø¨Ø®Ø´ Ø¨Ù‡ ØµÙˆØ±Øª Ø²ÛŒØ± ØªÙˆØ¶ÛŒØ­ Ø¯Ø§Ø¯Ù‡ Ù…ÛŒØ´ÙˆØ¯:

python
# Ø¯Ø± Ø§ÛŒÙ†Ø¬Ø§ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú¯ÙØªÚ¯ÙˆÙ‡Ø§ Ùˆ Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ø¬Ù…Ø¹Ø¢ÙˆØ±ÛŒ Ù…ÛŒØ´ÙˆØ¯ Ùˆ Ù†Ù…Ø§ÛŒØ´ Ø¯Ø§Ø¯Ù‡ Ù…ÛŒØ´ÙˆØ¯
if text == 'status':
    private_chats, bots, groups, broadcast_channels = 0, 0, 0, 0
    admin_in_groups, creator_in_groups = 0, 0
    admin_in_broadcast_channels, creator_in_channels = 0, 0
    unread_mentions, unread = 0, 0
    largest_group_member_count, largest_group_with_admin = 0, 0

    async for dialog in bot.iter_dialogs():
        entity = dialog.entity
        if isinstance(entity, types.Channel):
            broadcast_channels += 1
            if entity.creator:
                creator_in_channels += 1
        elif entity.megagroup:
            groups += 1
            if entity.creator or entity.admin_rights:
                admin_in_groups += 1
            if entity.creator:
                creator_in_groups += 1
        elif isinstance(entity, types.User):
            private_chats += 1
            if entity.bot:
                bots += 1
        elif isinstance(entity, types.Chat):
            groups += 1
            if entity.creator or entity.admin_rights:
                admin_in_groups += 1
            if entity.creator:
                creator_in_groups += 1

        unread_mentions += dialog.unread_mentions_count
        unread += dialog.unread_count

    # Ø³Ø§Ø®ØªÙ† Ú¯Ø²Ø§Ø±Ø´ Ø¨Ø§ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¬Ù…Ø¹Ø¢ÙˆØ±ÛŒ Ø´Ø¯Ù‡
    report = f'ÙˆØ¶Ø¹ÛŒØª:'
    report += f'\nÚ†ØªÙ‡Ø§ÛŒ Ø®ØµÙˆØµÛŒ: {private_chats}'
    report += f'\nØ±Ø¨Ø§ØªÙ‡Ø§: {bots}'
    report += f'\nÚ¯Ø±ÙˆÙ‡Ù‡Ø§: {groups}'
    report += f'\nÚ©Ø§Ù†Ø§Ù„Ù‡Ø§ÛŒ Ù¾Ø®Ø´: {broadcast_channels}'
    report += f'\nÙ…Ø¯ÛŒØ± Ø¯Ø± Ú¯Ø±ÙˆÙ‡Ù‡Ø§: {admin_in_groups}'
    report += f'\nØ³Ø§Ø²Ù†Ø¯Ù‡ Ø¯Ø± Ú¯Ø±ÙˆÙ‡Ù‡Ø§: {creator_in_groups}'
    report += f'\nÙ…Ø¯ÛŒØ± Ø¯Ø± Ú©Ø§Ù†Ø§Ù„Ù‡Ø§ÛŒ Ù¾Ø®Ø´: {admin_in_broadcast_channels}'
    report += f'\nØ³Ø§Ø²Ù†Ø¯Ù‡ Ø¯Ø± Ú©Ø§Ù†Ø§Ù„Ù‡Ø§: {creator_in_channels}'
    report += f'\nÙ…Ù†Ø´Ù†Ù‡Ø§ÛŒ Ø®ÙˆØ§Ù†Ø¯Ù‡ Ù†Ø´Ø¯Ù‡: {unread_mentions}'
    report += f'\nÙ¾ÛŒØ§Ù…Ù‡Ø§ÛŒ Ø®ÙˆØ§Ù†Ø¯Ù‡ Ù†Ø´Ø¯Ù‡: {unread}'
    report += f'\nØ¨Ø²Ø±Ú¯ØªØ±ÛŒÙ† ØªØ¹Ø¯Ø§Ø¯ Ø§Ø¹Ø¶Ø§ Ø¯Ø± Ú¯Ø±ÙˆÙ‡: {largest_group_member_count}'
    report += f'\nØ¨Ø²Ø±Ú¯ØªØ±ÛŒÙ† Ú¯Ø±ÙˆÙ‡ Ø¨Ø§ Ù…Ø¯ÛŒØ±: {largest_group_with_admin}'

    # Ø§Ø±Ø³Ø§Ù„ Ú¯Ø²Ø§Ø±Ø´ Ø¨Ù‡ Ú¯ÙØªÚ¯ÙˆÛŒ ÙØ¹Ù„ÛŒ
    await event.reply(font(report))
elif match := re.match(r'AddSudo (\d+)', text):
    # Ø§ÙØ²ÙˆØ¯Ù† ÛŒÚ© Ú©Ø§Ø±Ø¨Ø± Ø¨Ù‡ Ù„ÛŒØ³Øª Ù…Ø¯ÛŒØ±Ø§Ù† (Ø³ÙˆØ¯Ùˆ)
    id = int(match.group(1))
    data['admins'].append(id)
    put('data.json', data)
    await event.respond(font(f'{id} Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡ Ù„ÛŒØ³Øª Ù…Ø¯ÛŒØ±Ø§Ù† Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯!'))
# (Ø³Ø§ÛŒØ± Ù‚Ø³Ù…ØªÙ‡Ø§ÛŒ Ú©Ø¯ Ù†ÛŒØ² Ø§Ø¯Ø§Ù…Ù‡ Ø¯Ø§Ø±Ù†Ø¯)


Ø¯Ø± Ø§ÛŒÙ† Ø¨Ø®Ø´ØŒ Ø¨Ø§ ÙˆØ§Ø±Ø¯ Ú©Ø±Ø¯Ù† Ø¯Ø³ØªÙˆØ± `status`ØŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù…Ø®ØªÙ„ÙÛŒ Ø±Ø§ Ø§Ø² Ú¯ÙØªÚ¯ÙˆÙ‡Ø§ Ùˆ Ú©Ø§Ø±Ø¨Ø±Ø§Ù† (Ù…Ø«Ù„ ØªØ¹Ø¯Ø§Ø¯ Ú¯Ø±ÙˆÙ‡Ù‡Ø§ØŒ Ø±Ø¨Ø§ØªÙ‡Ø§ØŒ Ú©Ø§Ù†Ø§Ù„Ù‡Ø§ÛŒ Ù¾Ø®Ø´ Ùˆ ...) Ø¬Ù…Ø¹Ø¢ÙˆØ±ÛŒ Ù…ÛŒÚ©Ù†Ø¯ Ùˆ Ø¨Ù‡ Ú¯ÙˆÙ†Ù‡Ø§ÛŒ Ø²ÛŒØ¨Ø§ Ù†Ù…Ø§ÛŒØ´ Ù…ÛŒØ¯Ù‡Ø¯. Ù‡Ù…Ú†Ù†ÛŒÙ†ØŒ Ø¯Ø³ØªÙˆØ±Ø§ØªÛŒ Ø¨Ø±Ø§ÛŒ Ø§ÙØ²ÙˆØ¯Ù† Ùˆ Ø­Ø°Ù Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† Ù…Ø¯ÛŒØ± (Ø³ÙˆØ¯Ùˆ) Ùˆ ØªØºÛŒÛŒØ± Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù¾Ø±ÙˆÙØ§ÛŒÙ„ (Ù…Ø«Ù„ Ù†Ø§Ù…ØŒ Ù†Ø§Ù… Ø®Ø§Ù†ÙˆØ§Ø¯Ú¯ÛŒ Ùˆ ...) Ù†ÛŒØ² ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ù†Ø¯ Ú©Ù‡ Ø¨Ø§ Ø§Ù„Ú¯ÙˆÙ‡Ø§ÛŒ Ø®Ø§Øµ ØªØ´Ø®ØµØµ Ø¯Ø§Ø¯Ù‡Ø´Ø¯Ù‡Ø§Ù†Ø¯.


Ø¯Ø± Ø§ÛŒÙ† Ø¨Ø®Ø´ Ø§Ø² Ú©Ø¯ØŒ Ø¹Ù…Ù„ÛŒØ§ØªÙ‡Ø§ÛŒ Ù…Ø±ØªØ¨Ø· Ø¨Ø§ Ù…Ø®Ø§Ø·Ø¨Ø§Ù† Ùˆ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø§Ù†Ø¬Ø§Ù… Ù…ÛŒØ´ÙˆØ¯. Ø§ÛŒÙ† Ø¹Ù…Ù„ÛŒØ§Øª Ø´Ø§Ù…Ù„ Ø­Ø°Ù ØªÙ…Ø§Ø³Ù‡Ø§ØŒ Ø§Ø´ØªØ±Ø§Ú©Ú¯Ø°Ø§Ø±ÛŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª ØªÙ…Ø§Ø³ØŒ ØªÙ†Ø¸ÛŒÙ… Ø²Ù…Ø§Ù†Ø¨Ù†Ø¯ÛŒ Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„ Ø®ÙˆØ¯Ú©Ø§Ø± Ùˆ Ø§Ù‚Ø¯Ø§Ù…Ø§Øª Ù…Ø±ØªØ¨Ø· Ø¨Ø§ Ù¾ÛŒØ§Ù…Ù‡Ø§ÛŒ ÙˆØ±ÙˆØ¯ÛŒ Ø§Ø³Øª. Ø§ÛŒÙ† Ø¨Ø®Ø´ Ø¨Ù‡ ØµÙˆØ±Øª Ø²ÛŒØ± ØªÙˆØ¶ÛŒØ­ Ø¯Ø§Ø¯Ù‡ Ù…ÛŒØ´ÙˆØ¯:

python
# (Ø¯Ø± Ø§ÛŒÙ† Ù‚Ø³Ù…Øª Ø§Ø¯Ø§Ù…Ù‡ Ø¯ÛŒÚ¯Ø± Ø¨Ø®Ø´Ù‡Ø§ÛŒ Ú©Ø¯ Ø¢Ù…Ø¯Ù‡ Ø§Ø³Øª)

elif text == 'CleanContactsList':
    # Ø­Ø°Ù ØªÙ…Ø§Ø³Ù‡Ø§
    try:
        contacts = await bot(functions.contacts.GetContactsRequest(hash=0))
        await bot(functions.contacts.DeleteContactsRequest(id=[contact.id for contact in contacts.users]))
        await event.reply(font('ØªÙ…Ø§Ù… Ù…Ø®Ø§Ø·Ø¨ÛŒÙ† Ø´Ù…Ø§ Ø­Ø°Ù Ø´Ø¯Ù†Ø¯!'))
    except Exception as e:
        await event.reply(font(e))

elif text == 'Share':
    # Ø§Ø´ØªØ±Ø§Ú©Ú¯Ø°Ø§Ø±ÛŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª ØªÙ…Ø§Ø³
    me = await bot.get_me()
    await bot.send_file(event.chat_id, types.InputMediaContact(phone_number=me.phone, first_name=me.first_name, last_name=me.last_name or str(), vcard=str()))

elif match := re.match(r'ForwardTime (\d+)', text):
    # ØªÙ†Ø¸ÛŒÙ… Ø²Ù…Ø§Ù†Ø¨Ù†Ø¯ÛŒ Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„ Ø®ÙˆØ¯Ú©Ø§Ø±
    time = int(match.group(1))
    clock.spec = f'*/{time}    '
    clock.start()
    data['forwardtime'] = time
    put('data.json', data)
    await event.respond(font(f'Ø²Ù…Ø§Ù† Ø§Ø±Ø³Ø§Ù„ Ø®ÙˆØ¯Ú©Ø§Ø± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡ {time} Ø¯Ù‚ÛŒÙ‚Ù‡ ØªÙ†Ø¸ÛŒÙ… Ø´Ø¯!'))

# (Ø¯ÛŒÚ¯Ø± Ø¨Ø®Ø´Ù‡Ø§ÛŒ Ú©Ø¯ Ù†ÛŒØ² Ø§Ø¯Ø§Ù…Ù‡ Ø¯Ø§Ø±Ù†Ø¯)


Ø¯Ø± Ø§ÛŒÙ† Ø¨Ø®Ø´ØŒ Ø¹Ù…Ù„ÛŒØ§ØªÙ‡Ø§ÛŒÛŒ Ø¨Ø±Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª ØªÙ…Ø§Ø³Ù‡Ø§ (Ù…Ø§Ù†Ù†Ø¯ Ø­Ø°Ù ØªÙ…Ø§Ø³Ù‡Ø§)ØŒ Ø§Ø´ØªØ±Ø§Ú©Ú¯Ø°Ø§Ø±ÛŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª ØªÙ…Ø§Ø³ØŒ ØªÙ†Ø¸ÛŒÙ… Ø²Ù…Ø§Ù†Ø¨Ù†Ø¯ÛŒ Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„ Ø®ÙˆØ¯Ú©Ø§Ø± Ùˆ Ø§Ù‚Ø¯Ø§Ù…Ø§Øª Ù…Ø±ØªØ¨Ø· Ø¨Ø§ Ù¾ÛŒØ§Ù…Ù‡Ø§ÛŒ ÙˆØ±ÙˆØ¯ÛŒ (Ù…Ø«Ù„ Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ø§Ø·Ù„Ø§Ø¹Ø§Øª ÛŒÚ© Ù¾ÛŒØ§Ù… Ùˆ ...) Ø§Ø±Ø§Ø¦Ù‡ Ø´Ø¯Ù‡Ø§Ù†Ø¯. Ø§ÛŒÙ† Ø¯Ø³ØªÙˆØ±Ø§Øª Ø¨Ø§ Ø§Ù„Ú¯ÙˆÙ‡Ø§ÛŒ Ø®Ø§Øµ Ù…ØªÙ†Ø§Ø³Ø¨ Ø¨Ø§ Ù‡Ø± Ø¹Ù…Ù„ÛŒØ§Øª ØªØ´Ø®ØµØµ Ø¯Ø§Ø¯Ù‡Ø´Ø¯Ù‡Ø§Ù†Ø¯.


Ø¯Ø± Ø§ÛŒÙ† Ø¨Ø®Ø´ Ø§Ø² Ú©Ø¯ØŒ Ø§Ù‚Ø¯Ø§Ù…Ø§Øª Ù…Ø±ØªØ¨Ø· Ø¨Ø§ ÙÙˆØ±ÙˆØ§Ø±Ø¯ Ù¾ÛŒØ§Ù…Ù‡Ø§ Ø¨Ù‡ Ú¯Ø±ÙˆÙ‡Ù‡Ø§ØŒ Ú©Ø§Ù†Ø§Ù„Ù‡Ø§ Ùˆ Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ø§Ù†Ø¬Ø§Ù… Ù…ÛŒØ´ÙˆØ¯. Ø¹Ù…Ù„ÛŒØ§ØªÙ‡Ø§ÛŒÛŒ Ú¯ÙˆÙ†Ø§Ú¯ÙˆÙ† Ø´Ø§Ù…Ù„ Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù…Ù‡Ø§ Ø¨Ù‡ Ú¯Ø±ÙˆÙ‡Ù‡Ø§ØŒ Ú©Ø§Ù†Ø§Ù„Ù‡Ø§ Ùˆ Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ø¨Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² ÙÙˆØ±ÙˆØ§Ø±Ø¯ØŒ ØªÙ†Ø¸ÛŒÙ… Ø²Ù…Ø§Ù†Ø¨Ù†Ø¯ÛŒ Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„ Ø®ÙˆØ¯Ú©Ø§Ø± Ùˆ Ø°Ø®ÛŒØ±Ù‡ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù…Ø±Ø¨ÙˆØ· Ø¨Ù‡ ÙÙˆØ±ÙˆØ§Ø±Ø¯ Ø¯Ø± ÙØ§ÛŒÙ„ `data.json` Ø¢ÙˆØ±Ø¯Ù‡ Ø´Ø¯Ù‡Ø§Ù†Ø¯. Ø§ÛŒÙ† Ø¨Ø®Ø´ Ø¨Ù‡ ØµÙˆØ±Øª Ø²ÛŒØ± ØªÙˆØ¶ÛŒØ­ Ø¯Ø§Ø¯Ù‡ Ù…ÛŒØ´ÙˆØ¯:

python
# (Ø¯Ø± Ø§ÛŒÙ† Ù‚Ø³Ù…Øª Ø§Ø¯Ø§Ù…Ù‡ Ø¯ÛŒÚ¯Ø± Ø¨Ø®Ø´Ù‡Ø§ÛŒ Ú©Ø¯ Ø¢Ù…Ø¯Ù‡ Ø§Ø³Øª)

elif text == 'ForwardPrivates':
    # ÙÙˆØ±ÙˆØ§Ø±Ø¯ Ù¾ÛŒØ§Ù…Ù‡Ø§ Ø¨Ù‡ Ú¯ÙØªÚ¯ÙˆÙ‡Ø§ÛŒ Ø®ØµÙˆØµÛŒ
    i, limit_for_send = 0, 0
    async for dialog in bot.iter_dialogs():
        if isinstance(dialog.entity, types.User):
            try:
                await forward_message(dialog.id, event.reply_to_msg_id, event.chat_id, data['forwardreply'], data['forwardauthor'] == 'off')
                i += 1
                await asyncio.sleep(0.5)
            except FloodWaitError as error:
                limit_for_send = e.seconds
                try: await bot.send_message(dev, error)
                except: ...
                print(error)
                break
            except Exception as e:
                await bot.send_message(dev, font(e))

    print(f"Ù…Ø­Ø¯ÙˆØ¯ÛŒØª Ø²Ù…Ø§Ù†ÛŒ FloodWaitError Ø¨Ø±Ø§ÛŒ Ø±Ø¨Ø§Øª: {limit_for_send} Ø«Ø§Ù†ÛŒÙ‡")
    if limit_for_send:
        await asyncio.sleep(limit_for_send)
        await bot.send_message(dev, font(f"Ù…Ø­Ø¯ÙˆØ¯ÛŒØª Ø²Ù…Ø§Ù†ÛŒ FloodWaitError Ø¨Ø±Ø§ÛŒ Ø±Ø¨Ø§Øª: {limit_for_send} Ø«Ø§Ù†ÛŒÙ‡"))
    await asyncio.sleep(1)
    await event.reply(font(f'Ø¨Ù‡ {i} Ú¯ÙØªÚ¯ÙˆÛŒ Ø®ØµÙˆØµÛŒ ÙÙˆØ±ÙˆØ§Ø±Ø¯ Ø´Ø¯!'))

elif text == 'ForwardGroups':
    # ÙÙˆØ±ÙˆØ§Ø±Ø¯ Ù¾ÛŒØ§Ù…Ù‡Ø§ Ø¨Ù‡ Ú¯Ø±ÙˆÙ‡Ù‡Ø§
    i = 0
    async for dialog in bot.iter_dialogs():
        if isinstance(dialog.entity, types.Chat):
            try:
                await forward_message(dialog.id, event.reply_to_msg_id, event.chat_id, data['forwardreply'], data['forwardauthor'] == 'off')
                i += 1
            except FloodWaitError as error:
                limit_for_send = e.seconds
                try: await bot.send_message(dev, error)
                except: ...
                print(error)
                break
            except Exception as e:
                await bot.send_message(dev, font(e))

    print(f"Ù…Ø­Ø¯ÙˆØ¯ÛŒØª Ø²Ù…Ø§Ù†ÛŒ FloodWaitError Ø¨Ø±Ø§ÛŒ Ø±Ø¨Ø§Øª: {limit_for_send} Ø«Ø§Ù†ÛŒÙ‡")
    if limit_for_send:
        await asyncio.sleep(limit_for_send)
        await bot.send_message(dev, font(f"Ù…Ø­Ø¯ÙˆØ¯ÛŒØª Ø²Ù…Ø§Ù†ÛŒ FloodWaitError Ø¨Ø±Ø§ÛŒ Ø±Ø¨Ø§Øª: {limit_for_send} Ø«Ø§Ù†ÛŒÙ‡"))
    await asyncio.sleep(1)
    await event.reply(font(f'Ø¨Ù‡ {i} Ú¯Ø±ÙˆÙ‡ ÙÙˆØ±ÙˆØ§Ø±Ø¯ Ø´Ø¯!'))

# (Ø¯ÛŒÚ¯Ø± Ø¨Ø®Ø´Ù‡Ø§ÛŒ Ú©Ø¯ Ù†ÛŒØ² Ø§Ø¯Ø§Ù…Ù‡ Ø¯Ø§Ø±Ù†Ø¯)


Ø¯Ø± Ø§ÛŒÙ† Ø¨Ø®Ø´ØŒ Ø¹Ù…Ù„ÛŒØ§ØªÙ‡Ø§ÛŒ Ù…Ø®ØªÙ„Ù Ø¨Ø±Ø§ÛŒ ÙÙˆØ±ÙˆØ§Ø±Ø¯ Ù¾ÛŒØ§Ù…Ù‡Ø§ Ø¨Ù‡ Ú¯Ø±ÙˆÙ‡Ù‡Ø§ØŒ Ú©Ø§Ù†Ø§Ù„Ù‡Ø§ Ùˆ Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ø®ØµÙˆØµÛŒØŒ Ú¯Ø±ÙˆÙ‡Ù‡Ø§ Ùˆ Ú©Ø§Ù†Ø§Ù„Ù‡Ø§ÛŒ Ù¾Ø®Ø´ØŒ Ùˆ Ú¯Ø±ÙˆÙ‡Ù‡Ø§ÛŒ Ø³ÙˆÙ¾Ø± Ø§Ù†Ø¬Ø§Ù… Ù…ÛŒØ´ÙˆØ¯. Ù‡Ù…Ú†Ù†ÛŒÙ†ØŒ Ø²Ù…Ø§Ù†Ø¨Ù†Ø¯ÛŒ Ø¨Ø±Ø§ÛŒ ÙÙˆØ±ÙˆØ§Ø±Ø¯ Ø®ÙˆØ¯Ú©Ø§Ø± Ù†ÛŒØ² ØªÙ†Ø¸ÛŒÙ… Ù…ÛŒØ´ÙˆØ¯.


# ================================================================
try:
    import os
    import re
    import json
    import random
    import aiocron
    import asyncio
    import logging
    from telethon.sync import TelegramClient, events, functions, types
    from telethon.errors.rpcerrorlist import FloodWaitError
except ModuleNotFoundError:
    os.system('pip install --upgrade pip && pip install telethon && pip install asyncio && pip install aiocron && clear')
    os.sys.exit('installed the required packages !')

logging.basicConfig(filename="log.txt", filemode="a+",
                    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)


def get(file):
    with open(file, 'r') as r:
        return json.load(r)


def put(file, data):
    with open(file, 'w') as w:
        json.dump(data, w, indent=4)


def font(text):
    if isinstance(text, str):
        text = text.lower()
        return text.translate(text.maketrans('qwertyuiopasdfghjklzxcvbnm-0123456789', 'Ç«á´¡á´‡Ê€á´›Êá´œÉªá´á´˜á´€sá´…Ò“É¢Êœá´Šá´‹ÊŸá´¢xá´„á´ Ê™É´á´-ðŸŽðŸðŸðŸ‘ðŸ’ðŸ“ðŸ”ðŸ•ðŸ–ðŸ—'))
    else:
        return None


if not os.path.exists('data.json'):
    data = {'bot': 'on', 'autojoin': 'off', 'contact': 'off', 'secretary': 'off', 'forward': 'on', 'forwardauthor': 'off', 'forwardtime': 10,
            'forwardid': 0, 'forwardchat': None, 'forwardtype': None, 'forwardreply': None, 'subscription': 30, 'admins': [], 'groups': [], 'secretarytext': []}
    put('data.json', data)

api_id = 00000000
api_hash = '000000'

bot = TelegramClient(input('enter the session name : '), api_id, api_hash)

dev = 000000


async def forward_message(to_peer, id, from_peer, reply_text, drop_author):
    message = await bot(
        functions.messages.ForwardMessagesRequest(
            from_peer=from_peer,
            id=[id],
            to_peer=to_peer,
            drop_author=drop_author
        )
    )
    if reply_text:
        await bot.send_message(to_peer, reply_text, reply_to=message.updates[0].id)

forwardtime = get('data.json')['forwardtime']


@aiocron.crontab(f'*/{forwardtime}    ')
async def clock():
    data = get('data.json')
    if data['bot'] == 'on' and data['subscription'] != 0:
        if data['forward'] == 'on':
            if data['forwardid'] and data['forwardchat'] and data['forwardtype']:
                i, limit_for_send = 0, 0
                async for dialog in bot.iter_dialogs():
                    if (data['forwardtype'] == 'privates' and isinstance(dialog.entity, types.User)) or (data['forwardtype'] == 'groups' and isinstance(dialog.entity, types.Chat)) or (data['forwardtype'] == 'super groups' and isinstance(dialog.entity, types.Channel) and dialog.entity.megagroup):
                        try:
                            await forward_message(dialog.id, data['forwardid'], data['forwardchat'], data['forwardreply'], data['forwardauthor'] == 'off')
                            i += 1
                            await asyncio.sleep(0.5)
                        except FloodWaitError as error:
                            limit_for_send = e.seconds
                            try: await bot.send_message(dev, error)
                            except: ...
                            print(error)
                            break
                        except Exception as e:
                            await bot.send_message(dev, font(e))

                print(f"bot limit FloodWaitError: {limit_for_send} s")
                if limit_for_send:

                    await asyncio.sleep(limit_for_send)
                    await bot.send_message(dev, font(f"bot limit FloodWaitError: {limit_for_send} s"))
                await asyncio.sleep(1)
                await bot.send_message(dev, font(f'Sent to {i} of ' + data['forwardtype'] + ' !'))


@aiocron.crontab(f'*/12 12   *')
async def subscription():
    data = get('data.json')
    if data['subscription'] > 0:
        data['subscription'] -= 1
        put('data.json', data)
    else:
        await bot.send_message(dev, font('The subscription to this tabchi has ended !'))


@bot.on(events.NewMessage())
async def updateMessage(event):
    data = get('data.json')
    text = event.raw_text
    chat_id = event.chat_id
    from_id = event.sender_id
    if from_id == dev or from_id in data['admins'] or chat_id in data['groups']:
        if from_id == dev:
            if match := re.match(r'AddSubscription (\d+)', text):
                time = int(match.group(1))
                data['subscription'] += time
                put('data.json', data)
                await event.reply(font('The subscription of the robot has been successfully increased !'))
            elif match := re.match(r'LowSubscription (\d+)', text):
                time = int(match.group(1))
                data['subscription'] -= time
                put('data.json', data)
                await event.reply(font('The subscription of the robot has been successfully reduced !'))
        if from_id != dev and data['subscription'] == 0:
            return await event.reply(font('Your subscription has ended !'))
        if match := re.match(r'(Bot|Secretary|Contact|AutoJoin|Forward|ForwardAuthor) ([Oo][Nn]|[Oo][Ff][Ff])', text):
            index = match.group(1).lower()
            status = match.group(2).lower()
            data[index] = status
            put('data.json', data)
            await event.reply(font(f'{index} now is {status} !'))
        elif data['bot'] == 'on':
            if text == 'Help':
                await event.reply(f'''
Ø®Ø§Ù…ÙˆØ´ Ùˆ Ø±ÙˆØ´Ù† Ú©Ø±Ø¯Ù† Ø±Ø¨Ø§Øª :
Bot on | off
Ø®Ø§Ù…ÙˆØ´ Ùˆ Ø±ÙˆØ´Ù† Ú©Ø±Ø¯Ù† Ø­Ø§Ù„Øª Ù…Ù†Ø´ÛŒ :
Secretary on | off
Ø®Ø§Ù…ÙˆØ´ Ùˆ Ø±ÙˆØ´Ù† Ú©Ø±Ø¯Ù† Ø­Ø§Ù„Øª Ø°Ø®ÛŒØ±Ù‡ Ø®ÙˆØ¯Ú©Ø§Ø± Ù…Ø®Ø§Ø·Ø¨ :
Contact on | off
Ø®Ø§Ù…ÙˆØ´ Ùˆ Ø±ÙˆØ´Ù† Ú©Ø±Ø¯Ù† Ø­Ø§Ù„Øª Ø¹Ø¶Ùˆ Ø´Ø¯Ù† Ø®ÙˆØ¯Ú©Ø§Ø± Ù„ÛŒÙ†Ú© Ù‡Ø§ÛŒ Ø®ØµÙˆØµÛŒ :
AutoJoin on | off
Ø®Ø§Ù…ÙˆØ´ Ùˆ Ø±ÙˆØ´Ù† Ú©Ø±Ø¯Ù† ÙÙˆØ±ÙˆØ§Ø±Ø¯ Ø®ÙˆØ¯Ú©Ø§Ø± :
Forward on | off
ÙÙˆØ±ÙˆØ§Ø±Ø¯ Ø¨Ø¯ÙˆÙ† Ù†Ù‚Ù„ Ù‚ÙˆÙ„ ÛŒØ§ Ø¨Ø§ Ù†Ù‚Ù„ Ù‚ÙˆÙ„ :
ForwardAuthor on | off
Ø§Ø·Ù„Ø§Ø¹ Ø§Ø² Ø¢Ù†Ù„Ø§ÛŒÙ† Ø¨ÙˆØ¯Ù† Ø±Ø¨Ø§Øª :
Ping
Ú¯Ø±ÙØªÙ† Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø±Ø¨Ø§Øª :
Info
Ø¨Ø¯Ø³Øª Ø¢ÙˆØ±Ø¯Ù† Ø§Ø·Ù„Ø§Ø¹Ø§Øª ÛŒÚ© ÙØ±Ø¯ :
Id (REPLY)
Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø§Ø¯Ù…ÛŒÙ† Ø¨Ù‡ Ø±Ø¨Ø§Øª :
AddSudo (ID)

Ø­Ø°Ù Ø§Ø¯Ù…ÛŒÙ† Ø§Ø² Ø±Ø¨Ø§Øª :
DeleteSudo (ID)

Ú¯Ø±ÙØªÙ† Ù„ÛŒØ³Øª Ø§Ø¯Ù…ÛŒÙ† Ù‡Ø§ :
SudoList
ØªØºÛŒÛŒØ± Ù†Ø§Ù… Ø§Ú©Ø§Ù†Øª :
SetFirstName
ØªØºÛŒÛŒØ± Ù†Ø§Ù… Ø®Ø§Ù†ÙˆØ§Ø¯Ú¯ÛŒ Ø§Ú©Ø§Ù†Øª :
SetLastName
ØªØºÛŒÛŒØ± Ø¨ÛŒÙˆÚ¯Ø±Ø§ÙÛŒ Ø§Ú©Ø§Ù†Øª :
SetBiography
ØªØºÛŒÛŒØ± ÛŒÙˆØ²Ø±Ù†ÛŒÙ… Ø§Ú©Ø§Ù†Øª :
SetUserName
ØªÙ†Ø¸ÛŒÙ… Ø¹Ú©Ø³ Ø¨Ø±Ø§ÛŒ Ø¹Ú©Ø³ Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ø§Ú©Ø§Ù†Øª :
SetPhoto (REPLY)
Ø­Ø°Ù ØªÙ…Ø§Ù… Ø¹Ú©Ø³ Ù‡Ø§ÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ø±Ø¨Ø§Øª :
DeletePhoto
Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ù…ØªÙ† Ù…Ù†Ø´ÛŒ Ø±Ù†Ø¯ÙˆÙ… :
AddSecretary (TEXT)
Ø­Ø°Ù Ù…ØªÙ† Ù…Ù†Ø´ÛŒ :
DeleteSecretary (TEXT)
Ù„ÛŒØ³Øª Ù…ØªÙ† Ù‡Ø§ÛŒ Ù…Ù†Ø´ÛŒ Ø±Ù†Ø¯ÙˆÙ… :
SecretaryList
Ø§Ø³ØªØ§Ø±Øª Ú©Ø±Ø¯Ù† Ø±Ø¨Ø§Øª :
Start (@username)
Ø¹Ø¶Ùˆ Ø´Ø¯Ù† Ø¯Ø± ÛŒÚ© Ú¯Ø±ÙˆÙ‡ ÛŒØ§ Ú©Ø§Ù†Ø§Ù„ :
Join (@username)
Ù„ÙØª Ø¯Ø§Ø¯Ù† Ø§Ø² ÛŒÚ© Ú¯Ø±ÙˆÙ‡ ÛŒØ§ Ú©Ø§Ù†Ø§Ù„ :
Left (@username)
Ù¾Ø§Ú©Ø³Ø§Ø²ÛŒ Ù„ÛŒØ³Øª Ù…Ø®Ø§Ø·Ø¨ÛŒÙ† :
CleanContactsList
Ø§Ø´ØªØ±Ø§Ú© Ú¯Ø²Ø§Ø±ÛŒ Ø´Ù…Ø§Ø±Ù‡ Ø§Ú©Ø§Ù†Øª :
Share
ØªÙ†Ø¸ÛŒÙ… Ø²Ù…Ø§Ù† ÙÙˆØ±ÙˆØ§Ø±Ø¯ Ø®ÙˆØ¯Ú©Ø§Ø± :
ForwardTime (TIME)

Ø§Ø¯ Ú©Ø±Ø¯Ù† ÛŒÙ‡ Ú©Ø§Ø±Ø¨Ø± Ø¨Ù‡ Ù‡Ù…Ù‡ÛŒ Ú¯Ø±ÙˆÙ‡ Ù‡Ø§ :
AddAll (REPLY)
ÙÙˆØ±ÙˆØ§Ø±Ø¯ Ø¨Ø±Ø§ÛŒ Ù‡Ù…Ù‡ :
ForwardAll (REPLY)
ÙÙˆØ±ÙˆØ§Ø±Ø¯ Ø¨Ø±Ø§ÛŒ Ù¾ÛŒÙˆÛŒ Ù‡Ø§ :
ForwardPrivates (REPLY)
ÙÙˆØ±ÙˆØ§Ø±Ø¯ Ø¨Ø±Ø§ÛŒ Ú¯Ø±ÙˆÙ‡ Ù‡Ø§ÛŒ Ø¹Ø§Ø¯ÛŒ :
ForwardGroups (REPLY)
ÙÙˆØ±ÙˆØ§Ø±Ø¯ Ø¨Ø±Ø§ÛŒ Ø³ÙˆÙ¾Ø± Ú¯Ø±ÙˆÙ‡ Ù‡Ø§ :
ForwardSuperGroups (REPLY)
ØªÙ†Ø¸ÛŒÙ… ÙÙˆØ±ÙˆØ§Ø±Ø¯ Ø®ÙˆØ¯Ú©Ø§Ø± :
SetForward privates | super groups | groups
ØªÙ†Ø¸ÛŒÙ… Ù…ØªÙ† Ø±ÛŒÙ¾Ù„ÛŒ Ú©Ø±Ø¯Ù† Ø±ÙˆÛŒ Ù¾ÛŒØ§Ù… ÙÙˆØ±ÙˆØ§Ø±Ø¯ Ø´Ø¯Ù‡ :
SetForwardReply (REPLY)
Ø­Ø°Ù Ù…ØªÙ† Ø±ÛŒÙ¾Ù„ÛŒ Ø´Ø¯Ù‡ Ø±ÙˆÛŒ Ù¾ÛŒØ§Ù… ÙÙˆØ±ÙˆØ§Ø±Ø¯ Ø´Ø¯Ù‡ :
DeleteForwardReply
Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† ÛŒÚ© Ú¯Ø±ÙˆÙ‡ Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† Ú¯Ø±ÙˆÙ‡ Ù…Ø¯ÛŒØ±ÛŒØª Ø§Ú©Ø§Ù†Øª :
AddGp (IN GROUP)
Ø­Ø°Ù Ú©Ø±Ø¯Ù† ÛŒÚ© Ú¯Ø±ÙˆÙ‡ Ø§Ø² Ù„ÛŒØ³Øª Ú¯Ø±ÙˆÙ‡ Ù‡Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª Ø§Ú©Ø§Ù†Øª :
DeleteGp (IN GROUP)

Ø§Ø´ØªØ±Ø§Ú© Ø±Ø¨Ø§Øª : {data['subscription']}
''')
            elif text == 'Ping':
                await event.reply(font('I am Online !'))
            elif text == 'Info':
                private_chats = 0
                bots = 0
                groups = 0
                broadcast_channels = 0
                admin_in_groups = 0
                creator_in_groups = 0
                admin_in_broadcast_channels = 0
                creator_in_channels = 0
                unread_mentions = 0
                unread = 0
                largest_group_member_count = 0
                largest_group_with_admin = 0
                async for dialog in bot.iter_dialogs():
                    entity = dialog.entity
                    if isinstance(entity, types.Channel):
                        if entity.broadcast:
                            broadcast_channels += 1
                            if entity.creator or entity.admin_rights:
                                admin_in_broadcast_channels += 1
                            if entity.creator:
                                creator_in_channels += 1
                        elif entity.megagroup:
                            groups += 1
                            if entity.creator or entity.admin_rights:
                                admin_in_groups += 1
                            if entity.creator:
                                creator_in_groups += 1
                    elif isinstance(entity, types.User):
                        private_chats += 1
                        if entity.bot:
                            bots += 1
                    elif isinstance(entity, types.Chat):
                        groups += 1
                        if entity.creator or entity.admin_rights:
                            admin_in_groups += 1
                        if entity.creator:
                            creator_in_groups += 1
                    unread_mentions += dialog.unread_mentions_count
                    unread += dialog.unread_count
                list = f'status !'
                list += f'\nprivate chats : {private_chats}'
                list += f'\nbots : {bots}'
                list += f'\ngroups : {groups}'
                list += f'\nbroadcast channels : {broadcast_channels}'
                list += f'\nadmin in groups : {admin_in_groups}'
                list += f'\ncreator in groups : {creator_in_groups}'
                list += f'\nadmin in broadcast channels : {admin_in_broadcast_channels}'
                list += f'\ncreator in channels : {creator_in_channels}'
                list += f'\nunread mentions : {unread_mentions}'
                list += f'\nunread : {unread}'
                list += f'\nlargest group member count : {largest_group_member_count}'
                list += f'\nlargest group with admin : {largest_group_with_admin}'
                await event.reply(font(list))
            elif match := re.match(r'AddSudo (\d+)', text):
                id = int(match.group(1))
                data['admins'].append(id)

                put('data.json', data)
                await event.respond(font(f'{id} was successfully added to the list of admins !'))
            elif match := re.match(r'DeleteSudo (\d+)', text):
                id = int(match.group(1))
                data['admins'].remove(id)

                put('data.json', data)
                await event.respond(font(f'{id} was successfully removed from the list of admins !'))
            elif text == 'SudoList':
                list = font('Sudo List :')
                for id in data['admins']:
                    list += f'\nâ€¢ [á´œsá´‡Ê€](tg://user?id={id})'
                await event.respond(font(list))
            elif text == 'CleanSudoList':
                data['admins'] = []
                put('data.json', data)
            elif match := re.match(r'SetFirstName (.*)', text):
                try:
                    await bot(functions.account.UpdateProfileRequest(first_name=match.group(1)))
                    await event.reply(font('Your first name has been successfully changed !'))
                except Exception as e:
                    await event.reply(font(e))
            elif match := re.match(r'SetLastName (.*)', text):
                try:
                    await bot(functions.account.UpdateProfileRequest(last_name=match.group(1)))
                    await event.reply(font('Your last name has been successfully changed !'))
                except Exception as e:
                    await event.reply(font(e))
            elif match := re.match(r'SetBiography (.*)', text):
                try:
                    await bot(functions.account.UpdateProfileRequest(about=match.group(1)))
                    await event.reply(font('Your Biography has been successfully changed !'))
                except Exception as e:
                    await event.reply(font(e))
            elif match := re.match(r'SetUserName (.*)', text):
                try:
                    await bot(functions.account.UpdateUsernameRequest(username=match.group(1)))
                    await event.reply(font('Your username has been successfully changed !'))
                except Exception as e:
                    await event.reply(font(e))
            elif text == 'DeletePhoto':
                try:
                    photos = await bot.get_profile_photos('me')
                    for photo in photos:
                        await bot(functions.photos.DeletePhotosRequest(id=[types.InputPhoto(id=photo.id, access_hash=photo.access_hash, file_reference=photo.file_reference)]))
                    await event.reply(font('All your photos have been deleted !'))
                except Exception as e:
                    await event.reply(font(e))
            elif match := re.match(r'AddSecretary (.*)', text):
                if match.group(1) in data['secretarytext']:
                    await event.respond(font('This text is already saved !'))
                else:
                    data['secretarytext'].append(match.group(1))
                    put('data.json', data)
                    await event.respond(font('This text has been successfully added !'))
            elif match := re.match(r'DeleteSecretary (.*)', text):
                if match.group(1) in data['secretarytext']:
                    data['secretarytext'].remove(match.group(1))
                    put('data.json', data)
                    await event.respond(font('This text has been successfully removed !'))
                else:
                    await event.respond(font('This text does not exist !'))
            elif text == 'SecretaryList':
                list = font('Secretary List :')
                for text in data['secretarytext']:
                    list += f'\nâ€¢ {text}'
                await event.respond(font(list))
            elif match := re.match(r'Start (.*)', text):
                try:
                    await bot.send_message(match.group(1), '/start')
                    await event.reply(font('The bot started successfully !'))
                except Exception as e:
                    await event.reply(font(e))
            elif match := re.match(r'Join (.*)', text):
                invitelink = match.group(1)
                explode = invitelink.split('/')
                if len(explode)
 > 1:
                    try:
                        await bot(functions.messages.ImportChatInviteRequest(explode[-1]))
                        await event.reply(font('I became a member !'))
                    except Exception as e:
                        await event.reply(font(e))
                else:
                    try:
                        await bot(functions.channels.JoinChannelRequest(invitelink))
                        await event.reply(font('I became a member !'))
                    except Exception as e:
                        await event.reply(font(e))
            elif match := re.match(r'Left (.*)', text):
                invitelink = match.group(1)
                explode = invitelink.split('/')
                if len(explode)
 > 1:
                    try:
                        group = await bot.get_entity(invitelink)
                        await bot(functions.messages.DeleteExportedChatInviteRequest(int('-100' + str(group.id))))
                        await event.reply(font('I became a member !'))
                    except Exception as e:
                        await event.reply(font(e))
                else:
                    try:
                        await bot(functions.channels.LeaveChannelRequest(invitelink))
                        await event.reply(font('I became a member !'))
                    except Exception as e:
                        await event.reply(font(e))
            elif text == 'CleanContactsList':
                try:
                    contacts = await bot(functions.contacts.GetContactsRequest(hash=0))
                    await bot(functions.contacts.DeleteContactsRequest(id=[contact.id for contact in contacts.users]))
                    await event.reply(font('All your contacts have been deleted !'))
                except Exception as e:
                    await event.reply(font(e))
            elif text == 'Share':
                me = await bot.get_me()
                await bot.send_file(event.chat_id, types.InputMediaContact(phone_number=me.phone, first_name=me.first_name, last_name=me.last_name or str(), vcard=str()))
            elif match := re.match(r'ForwardTime (\d+)', text):
                time = int(match.group(1))
                clock.spec = f'*/{time}    '
                clock.start()
                data['forwardtime'] = time
                put('data.json', data)
                await event.respond(font(f'The forwarding time was automatically set to {time} minute !'))
            elif text == 'DeleteForwardReply':
                data['forwardreply'] = None
                put('data.json', data)
                await event.reply(font(f'Replay on the forwarded message was successfully deleted !'))
            elif event.is_reply:
                if text == 'Id':
                    getMessage = await event.get_reply_message()
                    sender = getMessage.sender
                    id = sender.id
                    first_name = sender.first_name
                    last_name = sender.last_name
                    username = sender.username
                    phone = sender.phone
                    list = f'id : {id}'
                    list += f'\nfirst name : {first_name}'
                    list += f'\nlast name : {last_name}'
                    list += f'\nusername : {username}'
                    list += f'\nphone : {phone}'
                    await event.reply(font(list))
                elif text == 'SetPhoto':
                    try:
                        message = await event.get_reply_message()
                        media = await bot.download_media(message)
                        await bot(functions.photos.UploadProfilePhotoRequest(await bot.upload_file(media)))
                        os.remove(media)
                        await event.reply(font('Your photo has been successfully changed !'))
                    except Exception as e:
                        await event.reply(font(e))
                elif text == 'AddAll':
                    getMessage = await event.get_reply_message()
                    id = getMessage.sender.id
                    i = 0
                    async for dialog in bot.iter_dialogs():
                        if isinstance(dialog.entity, types.Chat):
                            try:
                                await bot(functions.channels.InviteToChannelRequest(dialog.id, [id]))
                                i += 1
                            except Exception as e:
                                await event.reply(font(e))
                    await event.reply(font(f'User {id} was successfully added to {i} groups !'))
                elif text == 'ForwardAll':
                    i, limit_for_send = 0, 0
                    async for dialog in bot.iter_dialogs():
                        if isinstance(dialog.entity, (types.Chat, types.User)) or (isinstance(dialog.entity, types.Channel) and dialog.entity.megagroup):
                            try:
                                await forward_message(dialog.id, event.reply_to_msg_id, event.chat_id, data['forwardreply'], data['forwardauthor'] == 'off')
                                i += 1
                                await asyncio.sleep(0.5)
                            except FloodWaitError as error:
                                limit_for_send = e.seconds
                                try: await bot.send_message(dev, error)
                                except: ...
                                print(error)
                                break
                            except Exception as e:
                                await bot.send_message(dev, font(e))

                    print(f"bot limit FloodWaitError: {limit_for_send} s")
                    if limit_for_send:

                        await asyncio.sleep(limit_for_send)
                        await bot.send_message(dev, font(f"bot limit FloodWaitError: {limit_for_send} s"))
                    await asyncio.sleep(1)

                    await event.reply(font(f'Sent to {i} of groups and super groups and privates !'))
                elif text == 'ForwardPrivates':
                    i, limit_for_send = 0, 0
                    async for dialog in bot.iter_dialogs():
                        if isinstance(dialog.entity, types.User):
                            try:
                                await forward_message(dialog.id, event.reply_to_msg_id, event.chat_id, data['forwardreply'], data['forwardauthor'] == 'off')
                                i += 1
                                await asyncio.sleep(0.5)
                            except FloodWaitError as error:
                                limit_for_send = e.seconds
                                try: await bot.send_message(dev, error)
                                except: ...
                                print(error)
                                break
                            except Exception as e:
                                await bot.send_message(dev, font(e))

                    print(f"bot limit FloodWaitError: {limit_for_send} s")
                    if limit_for_send:

                        await asyncio.sleep(limit_for_send)
                        await bot.send_message(dev, font(f"bot limit FloodWaitError: {limit_for_send} s"))
                    await asyncio.sleep(1)
                    await event.reply(font(f'Sent to {i} of privates !'))
                elif text == 'ForwardGroups':
                    i = 0
                    async for dialog in bot.iter_dialogs():
                        if isinstance(dialog.entity, types.Chat):
                            try:
                                await forward_message(dialog.id, event.reply_to_msg_id, event.chat_id, data['forwardreply'], data['forwardauthor'] == 'off')
                                i += 1
                            except FloodWaitError as error:
                                limit_for_send = e.seconds
                                try: await bot.send_message(dev, error)
                                except: ...
                                print(error)
                                break
                            except Exception as e:
                                await bot.send_message(dev, font(e))

                    print(f"bot limit FloodWaitError: {limit_for_send} s")
                    if limit_for_send:

                        await asyncio.sleep(limit_for_send)
                        await bot.send_message(dev, font(f"bot limit FloodWaitError: {limit_for_send} s"))
                    await asyncio.sleep(1)
                    await event.reply(font(f'Sent to {i} of groups !'))
                elif text == 'ForwardSuperGroups':
                    i = 0
                    async for dialog in bot.iter_dialogs():
                        if isinstance(dialog.entity, types.Channel) and dialog.entity.megagroup:
                            try:
                                await forward_message(dialog.id, event.reply_to_msg_id, event.chat_id, data['forwardreply'], data['forwardauthor'] == 'off')
                                i += 1
                                await asyncio.sleep(0.5)
                            except FloodWaitError as error:
                                limit_for_send = e.seconds
                                try: await bot.send_message(dev, error)
                                except: ...
                                print(error)
                                break
                            except Exception as e:
                                await bot.send_message(dev, font(e))

                    print(f"bot limit FloodWaitError: {limit_for_send} s")
                    if limit_for_send:

                        await asyncio.sleep(limit_for_send)
                        await bot.send_message(dev, font(f"bot limit FloodWaitError: {limit_for_send} s"))
                    await asyncio.sleep(1)
                    await event.reply(font(f'Sent to {i} of super groups !'))
                elif match := re.match(r'SetForward (privates|super groups|groups)', text):
                    data['forwardid'] = event.reply_to_msg_id
                    data['forwardchat'] = event.chat_id
                    data['forwardtype'] = match.group(1)
                    put('data.json', data)
                    await event.reply(font('Automatic forward